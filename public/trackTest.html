<!DOCTYPE html>
<html>

<head>
  <title>Track Test</title>
  <meta name="color-scheme" content="dark light">
  <script src="./urchin.js"></script>
</head>

<body>
  <script>
    /**
     * Here we will create a catmullRomLerp() function to smoothly interpolate from p1 to p2 in 3D space based on the value of t. We will use the p5.Vector functions to perform vector math and keep the code as small as possible. It may look different, but the result returned from this function is the same as the equation defined above in the description, except that it will return a Vector rather than a scalar value.
     * 
     * @param {Vector} p0    -> Control point 0
     * @param {Vector} p1    -> Control point 1
     * @param {Vector} p2    -> Control point 2
     * @param {Vector} p3    -> Control point 3
     * @param {number} t        -> Progress of the interpolation. Range: [0.0, 1.0]
     */

    function catmullRomLerp(p0, p1, p2, p3, t) {
      let v = Vector;
      return (
        v.mult(p1, 2).add(
          v.sub(p2, p0).mult(t)).add(
            v.mult(p0, 2).sub(v.mult(p1, 5)).add(v.mult(p2, 4)).sub(p3).mult(t * t)).add(
              v.mult(p0, -1).add(v.mult(p1, 3)).sub(v.mult(p2, 3)).add(p3).mult(t * t * t))
      ).mult(0.5);
    }

    window.addEventListener("load", () => {
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const numPoints = 12;
      const radius = 200;
      const maxRadius = 380;
      ctx.strokeStyle = "white";
      ctx.lineWidth = 30;

      const points = [];
      for (let i = 0; i < numPoints; i++) {
        let a = i * Math.PI * 2 / numPoints;
        let rx = radius + Math.random() * (maxRadius - radius);
        let ry = radius + Math.random() * (maxRadius - radius);
        let x = canvas.width / 2 + Math.cos(a) * rx;
        let y = canvas.height / 2 + Math.sin(a) * ry;
        points.push(new Vector(x, y));
      }

      const lerpResolution = 4;
      const lerpedPoints = [];
      for (let i = 0; i < numPoints; i++) {
        const prev = i == 0 ? points[numPoints - 1] : points[i - 1];
        const current = points[i];
        const next = i + 1 == numPoints ? points[0] : points[i + 1];
        const last = i + 2 >= numPoints ? points[i + 2 - numPoints] : points[i + 2];
        for (let t = 0; t < 1; t += 1 / lerpResolution) {
          lerpedPoints.push(catmullRomLerp(prev, current, next, last, t));
        }
      }

      ctx.beginPath();
      for (let i = 0; i < lerpedPoints.length; i++) {
        const p = lerpedPoints[i];
        if (i == 0) {
          ctx.moveTo(p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
      }
      ctx.closePath();
      ctx.stroke();
    });
  </script>
  <canvas id="canvas" width="900" height="900"></canvas>
</body>

</html>